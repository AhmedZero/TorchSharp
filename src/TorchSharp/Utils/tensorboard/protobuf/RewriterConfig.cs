// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorboard/compat/proto/rewriter_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorboard {

  /// <summary>Holder for reflection information generated from tensorboard/compat/proto/rewriter_config.proto</summary>
  public static partial class RewriterConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorboard/compat/proto/rewriter_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RewriterConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci50ZW5zb3Jib2FyZC9jb21wYXQvcHJvdG8vcmV3cml0ZXJfY29uZmlnLnBy",
            "b3RvEgt0ZW5zb3Jib2FyZBopdGVuc29yYm9hcmQvY29tcGF0L3Byb3RvL2F0",
            "dHJfdmFsdWUucHJvdG8aLnRlbnNvcmJvYXJkL2NvbXBhdC9wcm90by92ZXJp",
            "Zmllcl9jb25maWcucHJvdG8iOwoTQXV0b1BhcmFsbGVsT3B0aW9ucxIOCgZl",
            "bmFibGUYASABKAgSFAoMbnVtX3JlcGxpY2FzGAIgASgFIisKFlNjb3BlZEFs",
            "bG9jYXRvck9wdGlvbnMSEQoJZW5hYmxlX29wGAEgAygJIu8UCg5SZXdyaXRl",
            "ckNvbmZpZxJEChVjcHVfbGF5b3V0X2NvbnZlcnNpb24YMiABKA4yJS50ZW5z",
            "b3Jib2FyZC5SZXdyaXRlckNvbmZpZy5DcHVMYXlvdXQSPAoQbGF5b3V0X29w",
            "dGltaXplchgBIAEoDjIiLnRlbnNvcmJvYXJkLlJld3JpdGVyQ29uZmlnLlRv",
            "Z2dsZRI8ChBjb25zdGFudF9mb2xkaW5nGAMgASgOMiIudGVuc29yYm9hcmQu",
            "UmV3cml0ZXJDb25maWcuVG9nZ2xlEj4KEnNoYXBlX29wdGltaXphdGlvbhgN",
            "IAEoDjIiLnRlbnNvcmJvYXJkLlJld3JpdGVyQ29uZmlnLlRvZ2dsZRI1Cgly",
            "ZW1hcHBpbmcYDiABKA4yIi50ZW5zb3Jib2FyZC5SZXdyaXRlckNvbmZpZy5U",
            "b2dnbGUSRwobY29tbW9uX3N1YmdyYXBoX2VsaW1pbmF0aW9uGBggASgOMiIu",
            "dGVuc29yYm9hcmQuUmV3cml0ZXJDb25maWcuVG9nZ2xlEkMKF2FyaXRobWV0",
            "aWNfb3B0aW1pemF0aW9uGAcgASgOMiIudGVuc29yYm9hcmQuUmV3cml0ZXJD",
            "b25maWcuVG9nZ2xlEkMKF2RlcGVuZGVuY3lfb3B0aW1pemF0aW9uGAggASgO",
            "MiIudGVuc29yYm9hcmQuUmV3cml0ZXJDb25maWcuVG9nZ2xlEj0KEWxvb3Bf",
            "b3B0aW1pemF0aW9uGAkgASgOMiIudGVuc29yYm9hcmQuUmV3cml0ZXJDb25m",
            "aWcuVG9nZ2xlEkEKFWZ1bmN0aW9uX29wdGltaXphdGlvbhgKIAEoDjIiLnRl",
            "bnNvcmJvYXJkLlJld3JpdGVyQ29uZmlnLlRvZ2dsZRI6Cg5kZWJ1Z19zdHJp",
            "cHBlchgLIAEoDjIiLnRlbnNvcmJvYXJkLlJld3JpdGVyQ29uZmlnLlRvZ2ds",
            "ZRIdChVkaXNhYmxlX21vZGVsX3BydW5pbmcYAiABKAgSSQodc2NvcGVkX2Fs",
            "bG9jYXRvcl9vcHRpbWl6YXRpb24YDyABKA4yIi50ZW5zb3Jib2FyZC5SZXdy",
            "aXRlckNvbmZpZy5Ub2dnbGUSRAoYcGluX3RvX2hvc3Rfb3B0aW1pemF0aW9u",
            "GBIgASgOMiIudGVuc29yYm9hcmQuUmV3cml0ZXJDb25maWcuVG9nZ2xlEkMK",
            "F2ltcGxlbWVudGF0aW9uX3NlbGVjdG9yGBYgASgOMiIudGVuc29yYm9hcmQu",
            "UmV3cml0ZXJDb25maWcuVG9nZ2xlEkAKFGF1dG9fbWl4ZWRfcHJlY2lzaW9u",
            "GBcgASgOMiIudGVuc29yYm9hcmQuUmV3cml0ZXJDb25maWcuVG9nZ2xlEkQK",
            "GGF1dG9fbWl4ZWRfcHJlY2lzaW9uX21rbBgZIAEoDjIiLnRlbnNvcmJvYXJk",
            "LlJld3JpdGVyQ29uZmlnLlRvZ2dsZRJEChhhdXRvX21peGVkX3ByZWNpc2lv",
            "bl9jcHUYHSABKA4yIi50ZW5zb3Jib2FyZC5SZXdyaXRlckNvbmZpZy5Ub2dn",
            "bGUSHgoWZGlzYWJsZV9tZXRhX29wdGltaXplchgTIAEoCBJBChV1c2VfcGx1",
            "Z2luX29wdGltaXplcnMYHCABKA4yIi50ZW5zb3Jib2FyZC5SZXdyaXRlckNv",
            "bmZpZy5Ub2dnbGUSUAoZbWV0YV9vcHRpbWl6ZXJfaXRlcmF0aW9ucxgMIAEo",
            "DjItLnRlbnNvcmJvYXJkLlJld3JpdGVyQ29uZmlnLk51bUl0ZXJhdGlvbnNU",
            "eXBlEhcKD21pbl9ncmFwaF9ub2RlcxgRIAEoBRI7CjNleHBlcmltZW50YWxf",
            "ZGlzYWJsZV9jb21wcmVzc2VkX3RlbnNvcl9vcHRpbWl6YXRpb24YGiABKAgS",
            "OwozZXhwZXJpbWVudGFsX2Rpc2FibGVfZm9sZGluZ19xdWFudGl6YXRpb25f",
            "ZW11bGF0aW9uGBsgASgIEkMKE21lbW9yeV9vcHRpbWl6YXRpb24YBCABKA4y",
            "Ji50ZW5zb3Jib2FyZC5SZXdyaXRlckNvbmZpZy5NZW1PcHRUeXBlEi8KJ21l",
            "bW9yeV9vcHRpbWl6ZXJfdGFyZ2V0X25vZGVfbmFtZV9zY29wZRgGIAEoCRIh",
            "ChltZXRhX29wdGltaXplcl90aW1lb3V0X21zGBQgASgDEjcKDWF1dG9fcGFy",
            "YWxsZWwYBSABKAsyIC50ZW5zb3Jib2FyZC5BdXRvUGFyYWxsZWxPcHRpb25z",
            "EiAKGGZhaWxfb25fb3B0aW1pemVyX2Vycm9ycxgVIAEoCBJCChVzY29wZWRf",
            "YWxsb2NhdG9yX29wdHMYECABKAsyIy50ZW5zb3Jib2FyZC5TY29wZWRBbGxv",
            "Y2F0b3JPcHRpb25zEhIKCm9wdGltaXplcnMYZCADKAkSTAoRY3VzdG9tX29w",
            "dGltaXplcnMYyAEgAygLMjAudGVuc29yYm9hcmQuUmV3cml0ZXJDb25maWcu",
            "Q3VzdG9tR3JhcGhPcHRpbWl6ZXISRQofaW50ZXJfb3B0aW1pemVyX3Zlcmlm",
            "aWVyX2NvbmZpZxisAiABKAsyGy50ZW5zb3Jib2FyZC5WZXJpZmllckNvbmZp",
            "ZxJHCiFwb3N0X29wdGltaXphdGlvbl92ZXJpZmllcl9jb25maWcYrQIgASgL",
            "MhsudGVuc29yYm9hcmQuVmVyaWZpZXJDb25maWcazAEKFEN1c3RvbUdyYXBo",
            "T3B0aW1pemVyEgwKBG5hbWUYASABKAkSWQoNcGFyYW1ldGVyX21hcBgCIAMo",
            "CzJCLnRlbnNvcmJvYXJkLlJld3JpdGVyQ29uZmlnLkN1c3RvbUdyYXBoT3B0",
            "aW1pemVyLlBhcmFtZXRlck1hcEVudHJ5GksKEVBhcmFtZXRlck1hcEVudHJ5",
            "EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLnRlbnNvcmJvYXJkLkF0",
            "dHJWYWx1ZToCOAEiZAoGVG9nZ2xlEgsKB0RFRkFVTFQQABIGCgJPThABEgcK",
            "A09GRhACEg4KCkFHR1JFU1NJVkUQAxIVChFFWFBFUklNRU5UQUxfTUxJUhAE",
            "EhUKEUVYUEVSSU1FTlRBTF9CT1RIEAUiSQoJQ3B1TGF5b3V0EhgKFE5PX0NP",
            "TlZFUlNJT05fT05fQ1BVEAASEAoMTkNIV19UT19OSFdDEAESEAoMTkhXQ19U",
            "T19OQ0hXEAIiPAoRTnVtSXRlcmF0aW9uc1R5cGUSFQoRREVGQVVMVF9OVU1f",
            "SVRFUlMQABIHCgNPTkUQARIHCgNUV08QAiKfAQoKTWVtT3B0VHlwZRITCg9E",
            "RUZBVUxUX01FTV9PUFQQABIOCgpOT19NRU1fT1BUEAESCgoGTUFOVUFMEAIS",
            "FwoTU1dBUFBJTkdfSEVVUklTVElDUxAEEhwKGFJFQ09NUFVUQVRJT05fSEVV",
            "UklTVElDUxAFEhkKFVNDSEVEVUxJTkdfSEVVUklTVElDUxAGEg4KCkhFVVJJ",
            "U1RJQ1MQA0KMAQoYb3JnLnRlbnNvcmZsb3cuZnJhbWV3b3JrQhRSZXdyaXRl",
            "ckNvbmZpZ1Byb3Rvc1ABWlVnaXRodWIuY29tL3RlbnNvcmZsb3cvdGVuc29y",
            "Zmxvdy90ZW5zb3JmbG93L2dvL2NvcmUvcHJvdG9idWYvZm9yX2NvcmVfcHJv",
            "dG9zX2dvX3Byb3Rv+AEBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorboard.AttrValueReflection.Descriptor, global::Tensorboard.VerifierConfigReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorboard.AutoParallelOptions), global::Tensorboard.AutoParallelOptions.Parser, new[]{ "Enable", "NumReplicas" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorboard.ScopedAllocatorOptions), global::Tensorboard.ScopedAllocatorOptions.Parser, new[]{ "EnableOp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorboard.RewriterConfig), global::Tensorboard.RewriterConfig.Parser, new[]{ "CpuLayoutConversion", "LayoutOptimizer", "ConstantFolding", "ShapeOptimization", "Remapping", "CommonSubgraphElimination", "ArithmeticOptimization", "DependencyOptimization", "LoopOptimization", "FunctionOptimization", "DebugStripper", "DisableModelPruning", "ScopedAllocatorOptimization", "PinToHostOptimization", "ImplementationSelector", "AutoMixedPrecision", "AutoMixedPrecisionMkl", "AutoMixedPrecisionCpu", "DisableMetaOptimizer", "UsePluginOptimizers", "MetaOptimizerIterations", "MinGraphNodes", "ExperimentalDisableCompressedTensorOptimization", "ExperimentalDisableFoldingQuantizationEmulation", "MemoryOptimization", "MemoryOptimizerTargetNodeNameScope", "MetaOptimizerTimeoutMs", "AutoParallel", "FailOnOptimizerErrors", "ScopedAllocatorOpts", "Optimizers", "CustomOptimizers", "InterOptimizerVerifierConfig", "PostOptimizationVerifierConfig" }, null, new[]{ typeof(global::Tensorboard.RewriterConfig.Types.Toggle), typeof(global::Tensorboard.RewriterConfig.Types.CpuLayout), typeof(global::Tensorboard.RewriterConfig.Types.NumIterationsType), typeof(global::Tensorboard.RewriterConfig.Types.MemOptType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer), global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer.Parser, new[]{ "Name", "ParameterMap" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class AutoParallelOptions : pb::IMessage<AutoParallelOptions> {
    private static readonly pb::MessageParser<AutoParallelOptions> _parser = new pb::MessageParser<AutoParallelOptions>(() => new AutoParallelOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AutoParallelOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorboard.RewriterConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions(AutoParallelOptions other) : this() {
      enable_ = other.enable_;
      numReplicas_ = other.numReplicas_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions Clone() {
      return new AutoParallelOptions(this);
    }

    /// <summary>Field number for the "enable" field.</summary>
    public const int EnableFieldNumber = 1;
    private bool enable_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enable {
      get { return enable_; }
      set {
        enable_ = value;
      }
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 2;
    private int numReplicas_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { return numReplicas_; }
      set {
        numReplicas_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AutoParallelOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AutoParallelOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enable != other.Enable) return false;
      if (NumReplicas != other.NumReplicas) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enable != false) hash ^= Enable.GetHashCode();
      if (NumReplicas != 0) hash ^= NumReplicas.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (NumReplicas != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumReplicas);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enable != false) {
        size += 1 + 1;
      }
      if (NumReplicas != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AutoParallelOptions other) {
      if (other == null) {
        return;
      }
      if (other.Enable != false) {
        Enable = other.Enable;
      }
      if (other.NumReplicas != 0) {
        NumReplicas = other.NumReplicas;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
          case 16: {
            NumReplicas = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ScopedAllocatorOptions : pb::IMessage<ScopedAllocatorOptions> {
    private static readonly pb::MessageParser<ScopedAllocatorOptions> _parser = new pb::MessageParser<ScopedAllocatorOptions>(() => new ScopedAllocatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScopedAllocatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorboard.RewriterConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions(ScopedAllocatorOptions other) : this() {
      enableOp_ = other.enableOp_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions Clone() {
      return new ScopedAllocatorOptions(this);
    }

    /// <summary>Field number for the "enable_op" field.</summary>
    public const int EnableOpFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_enableOp_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> enableOp_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If present, only perform optimization for these ops.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> EnableOp {
      get { return enableOp_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScopedAllocatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScopedAllocatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!enableOp_.Equals(other.enableOp_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= enableOp_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      enableOp_.WriteTo(output, _repeated_enableOp_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += enableOp_.CalculateSize(_repeated_enableOp_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScopedAllocatorOptions other) {
      if (other == null) {
        return;
      }
      enableOp_.Add(other.enableOp_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            enableOp_.AddEntriesFrom(input, _repeated_enableOp_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Graph rewriting is experimental and subject to change, not covered by any
  /// API stability guarantees.
  /// </summary>
  public sealed partial class RewriterConfig : pb::IMessage<RewriterConfig> {
    private static readonly pb::MessageParser<RewriterConfig> _parser = new pb::MessageParser<RewriterConfig>(() => new RewriterConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RewriterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorboard.RewriterConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig(RewriterConfig other) : this() {
      cpuLayoutConversion_ = other.cpuLayoutConversion_;
      layoutOptimizer_ = other.layoutOptimizer_;
      constantFolding_ = other.constantFolding_;
      shapeOptimization_ = other.shapeOptimization_;
      remapping_ = other.remapping_;
      commonSubgraphElimination_ = other.commonSubgraphElimination_;
      arithmeticOptimization_ = other.arithmeticOptimization_;
      dependencyOptimization_ = other.dependencyOptimization_;
      loopOptimization_ = other.loopOptimization_;
      functionOptimization_ = other.functionOptimization_;
      debugStripper_ = other.debugStripper_;
      disableModelPruning_ = other.disableModelPruning_;
      scopedAllocatorOptimization_ = other.scopedAllocatorOptimization_;
      pinToHostOptimization_ = other.pinToHostOptimization_;
      implementationSelector_ = other.implementationSelector_;
      autoMixedPrecision_ = other.autoMixedPrecision_;
      autoMixedPrecisionMkl_ = other.autoMixedPrecisionMkl_;
      autoMixedPrecisionCpu_ = other.autoMixedPrecisionCpu_;
      disableMetaOptimizer_ = other.disableMetaOptimizer_;
      usePluginOptimizers_ = other.usePluginOptimizers_;
      metaOptimizerIterations_ = other.metaOptimizerIterations_;
      minGraphNodes_ = other.minGraphNodes_;
      experimentalDisableCompressedTensorOptimization_ = other.experimentalDisableCompressedTensorOptimization_;
      experimentalDisableFoldingQuantizationEmulation_ = other.experimentalDisableFoldingQuantizationEmulation_;
      memoryOptimization_ = other.memoryOptimization_;
      memoryOptimizerTargetNodeNameScope_ = other.memoryOptimizerTargetNodeNameScope_;
      metaOptimizerTimeoutMs_ = other.metaOptimizerTimeoutMs_;
      autoParallel_ = other.autoParallel_ != null ? other.autoParallel_.Clone() : null;
      failOnOptimizerErrors_ = other.failOnOptimizerErrors_;
      scopedAllocatorOpts_ = other.scopedAllocatorOpts_ != null ? other.scopedAllocatorOpts_.Clone() : null;
      optimizers_ = other.optimizers_.Clone();
      customOptimizers_ = other.customOptimizers_.Clone();
      interOptimizerVerifierConfig_ = other.interOptimizerVerifierConfig_ != null ? other.interOptimizerVerifierConfig_.Clone() : null;
      postOptimizationVerifierConfig_ = other.postOptimizationVerifierConfig_ != null ? other.postOptimizationVerifierConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig Clone() {
      return new RewriterConfig(this);
    }

    /// <summary>Field number for the "cpu_layout_conversion" field.</summary>
    public const int CpuLayoutConversionFieldNumber = 50;
    private global::Tensorboard.RewriterConfig.Types.CpuLayout cpuLayoutConversion_ = global::Tensorboard.RewriterConfig.Types.CpuLayout.NoConversionOnCpu;
    /// <summary>
    /// CPU Conversion settings between NHCW and NCHW.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.CpuLayout CpuLayoutConversion {
      get { return cpuLayoutConversion_; }
      set {
        cpuLayoutConversion_ = value;
      }
    }

    /// <summary>Field number for the "layout_optimizer" field.</summary>
    public const int LayoutOptimizerFieldNumber = 1;
    private global::Tensorboard.RewriterConfig.Types.Toggle layoutOptimizer_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimize tensor layouts (default is ON)
    /// e.g. This will try to use NCHW layout on GPU which is faster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle LayoutOptimizer {
      get { return layoutOptimizer_; }
      set {
        layoutOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "constant_folding" field.</summary>
    public const int ConstantFoldingFieldNumber = 3;
    private global::Tensorboard.RewriterConfig.Types.Toggle constantFolding_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Fold constants (default is ON)
    /// Statically infer the value of tensors when possible, and materialize the
    /// result using constants.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle ConstantFolding {
      get { return constantFolding_; }
      set {
        constantFolding_ = value;
      }
    }

    /// <summary>Field number for the "shape_optimization" field.</summary>
    public const int ShapeOptimizationFieldNumber = 13;
    private global::Tensorboard.RewriterConfig.Types.Toggle shapeOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Shape optimizations (default is ON)
    /// Simplify computations made on shapes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle ShapeOptimization {
      get { return shapeOptimization_; }
      set {
        shapeOptimization_ = value;
      }
    }

    /// <summary>Field number for the "remapping" field.</summary>
    public const int RemappingFieldNumber = 14;
    private global::Tensorboard.RewriterConfig.Types.Toggle remapping_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Remapping (default is ON)
    /// Remap subgraphs onto more efficient implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle Remapping {
      get { return remapping_; }
      set {
        remapping_ = value;
      }
    }

    /// <summary>Field number for the "common_subgraph_elimination" field.</summary>
    public const int CommonSubgraphEliminationFieldNumber = 24;
    private global::Tensorboard.RewriterConfig.Types.Toggle commonSubgraphElimination_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Common subgraph elimination (default is ON)
    /// e.g. Simplify arithmetic ops; merge ops with same value (like constants).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle CommonSubgraphElimination {
      get { return commonSubgraphElimination_; }
      set {
        commonSubgraphElimination_ = value;
      }
    }

    /// <summary>Field number for the "arithmetic_optimization" field.</summary>
    public const int ArithmeticOptimizationFieldNumber = 7;
    private global::Tensorboard.RewriterConfig.Types.Toggle arithmeticOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Arithmetic optimizations (default is ON)
    /// e.g. Simplify arithmetic ops; merge ops with same value (like constants).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle ArithmeticOptimization {
      get { return arithmeticOptimization_; }
      set {
        arithmeticOptimization_ = value;
      }
    }

    /// <summary>Field number for the "dependency_optimization" field.</summary>
    public const int DependencyOptimizationFieldNumber = 8;
    private global::Tensorboard.RewriterConfig.Types.Toggle dependencyOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Control dependency optimizations (default is ON).
    /// Remove redundant control dependencies, which may enable other optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle DependencyOptimization {
      get { return dependencyOptimization_; }
      set {
        dependencyOptimization_ = value;
      }
    }

    /// <summary>Field number for the "loop_optimization" field.</summary>
    public const int LoopOptimizationFieldNumber = 9;
    private global::Tensorboard.RewriterConfig.Types.Toggle loopOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Loop optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle LoopOptimization {
      get { return loopOptimization_; }
      set {
        loopOptimization_ = value;
      }
    }

    /// <summary>Field number for the "function_optimization" field.</summary>
    public const int FunctionOptimizationFieldNumber = 10;
    private global::Tensorboard.RewriterConfig.Types.Toggle functionOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Function optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle FunctionOptimization {
      get { return functionOptimization_; }
      set {
        functionOptimization_ = value;
      }
    }

    /// <summary>Field number for the "debug_stripper" field.</summary>
    public const int DebugStripperFieldNumber = 11;
    private global::Tensorboard.RewriterConfig.Types.Toggle debugStripper_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Strips debug-related nodes from the graph (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle DebugStripper {
      get { return debugStripper_; }
      set {
        debugStripper_ = value;
      }
    }

    /// <summary>Field number for the "disable_model_pruning" field.</summary>
    public const int DisableModelPruningFieldNumber = 2;
    private bool disableModelPruning_;
    /// <summary>
    /// If true, don't remove unnecessary ops from the graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableModelPruning {
      get { return disableModelPruning_; }
      set {
        disableModelPruning_ = value;
      }
    }

    /// <summary>Field number for the "scoped_allocator_optimization" field.</summary>
    public const int ScopedAllocatorOptimizationFieldNumber = 15;
    private global::Tensorboard.RewriterConfig.Types.Toggle scopedAllocatorOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Try to allocate some independent Op outputs contiguously in order to
    /// merge or eliminate downstream Ops (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle ScopedAllocatorOptimization {
      get { return scopedAllocatorOptimization_; }
      set {
        scopedAllocatorOptimization_ = value;
      }
    }

    /// <summary>Field number for the "pin_to_host_optimization" field.</summary>
    public const int PinToHostOptimizationFieldNumber = 18;
    private global::Tensorboard.RewriterConfig.Types.Toggle pinToHostOptimization_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Force small ops onto the CPU (default is OFF).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle PinToHostOptimization {
      get { return pinToHostOptimization_; }
      set {
        pinToHostOptimization_ = value;
      }
    }

    /// <summary>Field number for the "implementation_selector" field.</summary>
    public const int ImplementationSelectorFieldNumber = 22;
    private global::Tensorboard.RewriterConfig.Types.Toggle implementationSelector_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Enable the swap of kernel implementations based on the device placement
    /// (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle ImplementationSelector {
      get { return implementationSelector_; }
      set {
        implementationSelector_ = value;
      }
    }

    /// <summary>Field number for the "auto_mixed_precision" field.</summary>
    public const int AutoMixedPrecisionFieldNumber = 23;
    private global::Tensorboard.RewriterConfig.Types.Toggle autoMixedPrecision_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimize data types for CUDA (default is OFF).
    /// This will try to use float16 on GPU which is faster.
    /// Note that this can change the numerical stability of the graph and may
    /// require the use of loss scaling to maintain model convergence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle AutoMixedPrecision {
      get { return autoMixedPrecision_; }
      set {
        autoMixedPrecision_ = value;
      }
    }

    /// <summary>Field number for the "auto_mixed_precision_mkl" field.</summary>
    public const int AutoMixedPrecisionMklFieldNumber = 25;
    private global::Tensorboard.RewriterConfig.Types.Toggle autoMixedPrecisionMkl_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimize data types for MKL (default is OFF).
    /// This will try to use bfloat16 on CPUs, which is faster.
    /// Note that this can change the numerical stability of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle AutoMixedPrecisionMkl {
      get { return autoMixedPrecisionMkl_; }
      set {
        autoMixedPrecisionMkl_ = value;
      }
    }

    /// <summary>Field number for the "auto_mixed_precision_cpu" field.</summary>
    public const int AutoMixedPrecisionCpuFieldNumber = 29;
    private global::Tensorboard.RewriterConfig.Types.Toggle autoMixedPrecisionCpu_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Emulate a model using data type float16 on CPU (default is OFF).
    /// This will try to emulate the float16 inputs and outputs of an operator
    /// on CPU to have better correlation with float16 on GPU; however the
    /// computation in the operator is based on float32.
    /// Note that this can change the numerical stability of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle AutoMixedPrecisionCpu {
      get { return autoMixedPrecisionCpu_; }
      set {
        autoMixedPrecisionCpu_ = value;
      }
    }

    /// <summary>Field number for the "disable_meta_optimizer" field.</summary>
    public const int DisableMetaOptimizerFieldNumber = 19;
    private bool disableMetaOptimizer_;
    /// <summary>
    /// Disable the entire meta optimizer (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableMetaOptimizer {
      get { return disableMetaOptimizer_; }
      set {
        disableMetaOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "use_plugin_optimizers" field.</summary>
    public const int UsePluginOptimizersFieldNumber = 28;
    private global::Tensorboard.RewriterConfig.Types.Toggle usePluginOptimizers_ = global::Tensorboard.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimizers registered by plugin (default is ON)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.Toggle UsePluginOptimizers {
      get { return usePluginOptimizers_; }
      set {
        usePluginOptimizers_ = value;
      }
    }

    /// <summary>Field number for the "meta_optimizer_iterations" field.</summary>
    public const int MetaOptimizerIterationsFieldNumber = 12;
    private global::Tensorboard.RewriterConfig.Types.NumIterationsType metaOptimizerIterations_ = global::Tensorboard.RewriterConfig.Types.NumIterationsType.DefaultNumIters;
    /// <summary>
    /// Controls how many times we run the optimizers in meta optimizer (default
    /// is once).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.NumIterationsType MetaOptimizerIterations {
      get { return metaOptimizerIterations_; }
      set {
        metaOptimizerIterations_ = value;
      }
    }

    /// <summary>Field number for the "min_graph_nodes" field.</summary>
    public const int MinGraphNodesFieldNumber = 17;
    private int minGraphNodes_;
    /// <summary>
    /// The minimum number of nodes in a graph to optimizer. For smaller graphs,
    /// optimization is skipped.
    /// 0 means the system picks an appropriate number.
    /// &lt; 0 means do not skip optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinGraphNodes {
      get { return minGraphNodes_; }
      set {
        minGraphNodes_ = value;
      }
    }

    /// <summary>Field number for the "experimental_disable_compressed_tensor_optimization" field.</summary>
    public const int ExperimentalDisableCompressedTensorOptimizationFieldNumber = 26;
    private bool experimentalDisableCompressedTensorOptimization_;
    /// <summary>
    /// Disable optimizations that assume compressed tensors. Note that this flag
    /// is experimental and may be removed in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ExperimentalDisableCompressedTensorOptimization {
      get { return experimentalDisableCompressedTensorOptimization_; }
      set {
        experimentalDisableCompressedTensorOptimization_ = value;
      }
    }

    /// <summary>Field number for the "experimental_disable_folding_quantization_emulation" field.</summary>
    public const int ExperimentalDisableFoldingQuantizationEmulationFieldNumber = 27;
    private bool experimentalDisableFoldingQuantizationEmulation_;
    /// <summary>
    /// Disable folding quantization emulation ops such as FakeQuantWithMinMax* and
    /// QuantizeAndDequantize*. Some compilers (e.g. the TF-to-tflite converter)
    /// have to extract quantization configs (e.g. min/max range, number of bits,
    /// and per-channel) from the quantization emulation ops. Note that this flag
    /// is experimental and may be removed in the future. See b/174138564 for more
    /// details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ExperimentalDisableFoldingQuantizationEmulation {
      get { return experimentalDisableFoldingQuantizationEmulation_; }
      set {
        experimentalDisableFoldingQuantizationEmulation_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimization" field.</summary>
    public const int MemoryOptimizationFieldNumber = 4;
    private global::Tensorboard.RewriterConfig.Types.MemOptType memoryOptimization_ = global::Tensorboard.RewriterConfig.Types.MemOptType.DefaultMemOpt;
    /// <summary>
    /// Configures memory optimization passes through the meta-optimizer. Has no
    /// effect on manually requested memory optimization passes in the optimizers
    /// field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.RewriterConfig.Types.MemOptType MemoryOptimization {
      get { return memoryOptimization_; }
      set {
        memoryOptimization_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimizer_target_node_name_scope" field.</summary>
    public const int MemoryOptimizerTargetNodeNameScopeFieldNumber = 6;
    private string memoryOptimizerTargetNodeNameScope_ = "";
    /// <summary>
    /// A node name scope for node names which are valid outputs of recomputations.
    /// Inputs to nodes that match this scope may be recomputed (subject either to
    /// manual annotation of those input nodes or to manual annotation and
    /// heuristics depending on memory_optimization), but the nodes themselves will
    /// not be recomputed. This matches any sub-scopes as well, meaning the scope
    /// can appear not just as a top-level scope. For example, if the value is
    /// "gradients/", the default, it will match node name "gradients/foo",
    /// "foo/gradients/bar", but not "foo_gradients/"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MemoryOptimizerTargetNodeNameScope {
      get { return memoryOptimizerTargetNodeNameScope_; }
      set {
        memoryOptimizerTargetNodeNameScope_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "meta_optimizer_timeout_ms" field.</summary>
    public const int MetaOptimizerTimeoutMsFieldNumber = 20;
    private long metaOptimizerTimeoutMs_;
    /// <summary>
    /// Maximum number of milliseconds to spend optimizing a single graph before
    /// timing out. If less than or equal to 0 (default value) the optimizer will
    /// never time out.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MetaOptimizerTimeoutMs {
      get { return metaOptimizerTimeoutMs_; }
      set {
        metaOptimizerTimeoutMs_ = value;
      }
    }

    /// <summary>Field number for the "auto_parallel" field.</summary>
    public const int AutoParallelFieldNumber = 5;
    private global::Tensorboard.AutoParallelOptions autoParallel_;
    /// <summary>
    /// Configures AutoParallel optimization passes either through the
    /// meta-optimizer or when manually specified through the optimizers field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.AutoParallelOptions AutoParallel {
      get { return autoParallel_; }
      set {
        autoParallel_ = value;
      }
    }

    /// <summary>Field number for the "fail_on_optimizer_errors" field.</summary>
    public const int FailOnOptimizerErrorsFieldNumber = 21;
    private bool failOnOptimizerErrors_;
    /// <summary>
    /// If true, any optimization pass failing will cause the MetaOptimizer to
    /// stop with an error. By default - or when set to false, failing passes are
    /// skipped silently.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FailOnOptimizerErrors {
      get { return failOnOptimizerErrors_; }
      set {
        failOnOptimizerErrors_ = value;
      }
    }

    /// <summary>Field number for the "scoped_allocator_opts" field.</summary>
    public const int ScopedAllocatorOptsFieldNumber = 16;
    private global::Tensorboard.ScopedAllocatorOptions scopedAllocatorOpts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.ScopedAllocatorOptions ScopedAllocatorOpts {
      get { return scopedAllocatorOpts_; }
      set {
        scopedAllocatorOpts_ = value;
      }
    }

    /// <summary>Field number for the "optimizers" field.</summary>
    public const int OptimizersFieldNumber = 100;
    private static readonly pb::FieldCodec<string> _repeated_optimizers_codec
        = pb::FieldCodec.ForString(802);
    private readonly pbc::RepeatedField<string> optimizers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If non-empty, will use this as an alternative way to specify a list of
    /// optimizations to turn on and the order of the optimizations (replacing the
    /// meta-optimizer).
    ///
    /// Of the RewriterConfig options, only the AutoParallel configuration options
    /// (the auto_parallel field) apply to manually requested optimization passes
    /// ("autoparallel"). Memory optimization passes ("memory") invoked here are
    /// not configurable (in contrast to memory optimization passes through the
    /// meta-optimizer) and act only on manual op annotations.
    ///
    /// Custom optimizers (see custom_optimizers) that are not part of this
    /// schedule will be run after - in the order that they were specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Optimizers {
      get { return optimizers_; }
    }

    /// <summary>Field number for the "custom_optimizers" field.</summary>
    public const int CustomOptimizersFieldNumber = 200;
    private static readonly pb::FieldCodec<global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer> _repeated_customOptimizers_codec
        = pb::FieldCodec.ForMessage(1602, global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer.Parser);
    private readonly pbc::RepeatedField<global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer> customOptimizers_ = new pbc::RepeatedField<global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer>();
    /// <summary>
    /// list of CustomGraphOptimizers to apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorboard.RewriterConfig.Types.CustomGraphOptimizer> CustomOptimizers {
      get { return customOptimizers_; }
    }

    /// <summary>Field number for the "inter_optimizer_verifier_config" field.</summary>
    public const int InterOptimizerVerifierConfigFieldNumber = 300;
    private global::Tensorboard.VerifierConfig interOptimizerVerifierConfig_;
    /// <summary>
    /// VerifierConfig specifying the verifiers to be run after every optimizer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.VerifierConfig InterOptimizerVerifierConfig {
      get { return interOptimizerVerifierConfig_; }
      set {
        interOptimizerVerifierConfig_ = value;
      }
    }

    /// <summary>Field number for the "post_optimization_verifier_config" field.</summary>
    public const int PostOptimizationVerifierConfigFieldNumber = 301;
    private global::Tensorboard.VerifierConfig postOptimizationVerifierConfig_;
    /// <summary>
    /// VerifierConfig specifying the verifiers to be run at the end, after all
    /// optimizers have run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorboard.VerifierConfig PostOptimizationVerifierConfig {
      get { return postOptimizationVerifierConfig_; }
      set {
        postOptimizationVerifierConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RewriterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RewriterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CpuLayoutConversion != other.CpuLayoutConversion) return false;
      if (LayoutOptimizer != other.LayoutOptimizer) return false;
      if (ConstantFolding != other.ConstantFolding) return false;
      if (ShapeOptimization != other.ShapeOptimization) return false;
      if (Remapping != other.Remapping) return false;
      if (CommonSubgraphElimination != other.CommonSubgraphElimination) return false;
      if (ArithmeticOptimization != other.ArithmeticOptimization) return false;
      if (DependencyOptimization != other.DependencyOptimization) return false;
      if (LoopOptimization != other.LoopOptimization) return false;
      if (FunctionOptimization != other.FunctionOptimization) return false;
      if (DebugStripper != other.DebugStripper) return false;
      if (DisableModelPruning != other.DisableModelPruning) return false;
      if (ScopedAllocatorOptimization != other.ScopedAllocatorOptimization) return false;
      if (PinToHostOptimization != other.PinToHostOptimization) return false;
      if (ImplementationSelector != other.ImplementationSelector) return false;
      if (AutoMixedPrecision != other.AutoMixedPrecision) return false;
      if (AutoMixedPrecisionMkl != other.AutoMixedPrecisionMkl) return false;
      if (AutoMixedPrecisionCpu != other.AutoMixedPrecisionCpu) return false;
      if (DisableMetaOptimizer != other.DisableMetaOptimizer) return false;
      if (UsePluginOptimizers != other.UsePluginOptimizers) return false;
      if (MetaOptimizerIterations != other.MetaOptimizerIterations) return false;
      if (MinGraphNodes != other.MinGraphNodes) return false;
      if (ExperimentalDisableCompressedTensorOptimization != other.ExperimentalDisableCompressedTensorOptimization) return false;
      if (ExperimentalDisableFoldingQuantizationEmulation != other.ExperimentalDisableFoldingQuantizationEmulation) return false;
      if (MemoryOptimization != other.MemoryOptimization) return false;
      if (MemoryOptimizerTargetNodeNameScope != other.MemoryOptimizerTargetNodeNameScope) return false;
      if (MetaOptimizerTimeoutMs != other.MetaOptimizerTimeoutMs) return false;
      if (!object.Equals(AutoParallel, other.AutoParallel)) return false;
      if (FailOnOptimizerErrors != other.FailOnOptimizerErrors) return false;
      if (!object.Equals(ScopedAllocatorOpts, other.ScopedAllocatorOpts)) return false;
      if(!optimizers_.Equals(other.optimizers_)) return false;
      if(!customOptimizers_.Equals(other.customOptimizers_)) return false;
      if (!object.Equals(InterOptimizerVerifierConfig, other.InterOptimizerVerifierConfig)) return false;
      if (!object.Equals(PostOptimizationVerifierConfig, other.PostOptimizationVerifierConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CpuLayoutConversion != global::Tensorboard.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) hash ^= CpuLayoutConversion.GetHashCode();
      if (LayoutOptimizer != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= LayoutOptimizer.GetHashCode();
      if (ConstantFolding != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= ConstantFolding.GetHashCode();
      if (ShapeOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= ShapeOptimization.GetHashCode();
      if (Remapping != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= Remapping.GetHashCode();
      if (CommonSubgraphElimination != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= CommonSubgraphElimination.GetHashCode();
      if (ArithmeticOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= ArithmeticOptimization.GetHashCode();
      if (DependencyOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= DependencyOptimization.GetHashCode();
      if (LoopOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= LoopOptimization.GetHashCode();
      if (FunctionOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= FunctionOptimization.GetHashCode();
      if (DebugStripper != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= DebugStripper.GetHashCode();
      if (DisableModelPruning != false) hash ^= DisableModelPruning.GetHashCode();
      if (ScopedAllocatorOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= ScopedAllocatorOptimization.GetHashCode();
      if (PinToHostOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= PinToHostOptimization.GetHashCode();
      if (ImplementationSelector != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= ImplementationSelector.GetHashCode();
      if (AutoMixedPrecision != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= AutoMixedPrecision.GetHashCode();
      if (AutoMixedPrecisionMkl != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= AutoMixedPrecisionMkl.GetHashCode();
      if (AutoMixedPrecisionCpu != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= AutoMixedPrecisionCpu.GetHashCode();
      if (DisableMetaOptimizer != false) hash ^= DisableMetaOptimizer.GetHashCode();
      if (UsePluginOptimizers != global::Tensorboard.RewriterConfig.Types.Toggle.Default) hash ^= UsePluginOptimizers.GetHashCode();
      if (MetaOptimizerIterations != global::Tensorboard.RewriterConfig.Types.NumIterationsType.DefaultNumIters) hash ^= MetaOptimizerIterations.GetHashCode();
      if (MinGraphNodes != 0) hash ^= MinGraphNodes.GetHashCode();
      if (ExperimentalDisableCompressedTensorOptimization != false) hash ^= ExperimentalDisableCompressedTensorOptimization.GetHashCode();
      if (ExperimentalDisableFoldingQuantizationEmulation != false) hash ^= ExperimentalDisableFoldingQuantizationEmulation.GetHashCode();
      if (MemoryOptimization != global::Tensorboard.RewriterConfig.Types.MemOptType.DefaultMemOpt) hash ^= MemoryOptimization.GetHashCode();
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) hash ^= MemoryOptimizerTargetNodeNameScope.GetHashCode();
      if (MetaOptimizerTimeoutMs != 0L) hash ^= MetaOptimizerTimeoutMs.GetHashCode();
      if (autoParallel_ != null) hash ^= AutoParallel.GetHashCode();
      if (FailOnOptimizerErrors != false) hash ^= FailOnOptimizerErrors.GetHashCode();
      if (scopedAllocatorOpts_ != null) hash ^= ScopedAllocatorOpts.GetHashCode();
      hash ^= optimizers_.GetHashCode();
      hash ^= customOptimizers_.GetHashCode();
      if (interOptimizerVerifierConfig_ != null) hash ^= InterOptimizerVerifierConfig.GetHashCode();
      if (postOptimizationVerifierConfig_ != null) hash ^= PostOptimizationVerifierConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LayoutOptimizer != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LayoutOptimizer);
      }
      if (DisableModelPruning != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableModelPruning);
      }
      if (ConstantFolding != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ConstantFolding);
      }
      if (MemoryOptimization != global::Tensorboard.RewriterConfig.Types.MemOptType.DefaultMemOpt) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MemoryOptimization);
      }
      if (autoParallel_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoParallel);
      }
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(MemoryOptimizerTargetNodeNameScope);
      }
      if (ArithmeticOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(56);
        output.WriteEnum((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DependencyOptimization);
      }
      if (LoopOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(72);
        output.WriteEnum((int) LoopOptimization);
      }
      if (FunctionOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(80);
        output.WriteEnum((int) FunctionOptimization);
      }
      if (DebugStripper != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(88);
        output.WriteEnum((int) DebugStripper);
      }
      if (MetaOptimizerIterations != global::Tensorboard.RewriterConfig.Types.NumIterationsType.DefaultNumIters) {
        output.WriteRawTag(96);
        output.WriteEnum((int) MetaOptimizerIterations);
      }
      if (ShapeOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(104);
        output.WriteEnum((int) ShapeOptimization);
      }
      if (Remapping != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(112);
        output.WriteEnum((int) Remapping);
      }
      if (ScopedAllocatorOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(120);
        output.WriteEnum((int) ScopedAllocatorOptimization);
      }
      if (scopedAllocatorOpts_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ScopedAllocatorOpts);
      }
      if (MinGraphNodes != 0) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(MinGraphNodes);
      }
      if (PinToHostOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) PinToHostOptimization);
      }
      if (DisableMetaOptimizer != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(DisableMetaOptimizer);
      }
      if (MetaOptimizerTimeoutMs != 0L) {
        output.WriteRawTag(160, 1);
        output.WriteInt64(MetaOptimizerTimeoutMs);
      }
      if (FailOnOptimizerErrors != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(FailOnOptimizerErrors);
      }
      if (ImplementationSelector != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(176, 1);
        output.WriteEnum((int) ImplementationSelector);
      }
      if (AutoMixedPrecision != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(184, 1);
        output.WriteEnum((int) AutoMixedPrecision);
      }
      if (CommonSubgraphElimination != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(192, 1);
        output.WriteEnum((int) CommonSubgraphElimination);
      }
      if (AutoMixedPrecisionMkl != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(200, 1);
        output.WriteEnum((int) AutoMixedPrecisionMkl);
      }
      if (ExperimentalDisableCompressedTensorOptimization != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(ExperimentalDisableCompressedTensorOptimization);
      }
      if (ExperimentalDisableFoldingQuantizationEmulation != false) {
        output.WriteRawTag(216, 1);
        output.WriteBool(ExperimentalDisableFoldingQuantizationEmulation);
      }
      if (UsePluginOptimizers != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(224, 1);
        output.WriteEnum((int) UsePluginOptimizers);
      }
      if (AutoMixedPrecisionCpu != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(232, 1);
        output.WriteEnum((int) AutoMixedPrecisionCpu);
      }
      if (CpuLayoutConversion != global::Tensorboard.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) {
        output.WriteRawTag(144, 3);
        output.WriteEnum((int) CpuLayoutConversion);
      }
      optimizers_.WriteTo(output, _repeated_optimizers_codec);
      customOptimizers_.WriteTo(output, _repeated_customOptimizers_codec);
      if (interOptimizerVerifierConfig_ != null) {
        output.WriteRawTag(226, 18);
        output.WriteMessage(InterOptimizerVerifierConfig);
      }
      if (postOptimizationVerifierConfig_ != null) {
        output.WriteRawTag(234, 18);
        output.WriteMessage(PostOptimizationVerifierConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CpuLayoutConversion != global::Tensorboard.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CpuLayoutConversion);
      }
      if (LayoutOptimizer != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LayoutOptimizer);
      }
      if (ConstantFolding != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ConstantFolding);
      }
      if (ShapeOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ShapeOptimization);
      }
      if (Remapping != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Remapping);
      }
      if (CommonSubgraphElimination != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CommonSubgraphElimination);
      }
      if (ArithmeticOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DependencyOptimization);
      }
      if (LoopOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LoopOptimization);
      }
      if (FunctionOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FunctionOptimization);
      }
      if (DebugStripper != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DebugStripper);
      }
      if (DisableModelPruning != false) {
        size += 1 + 1;
      }
      if (ScopedAllocatorOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScopedAllocatorOptimization);
      }
      if (PinToHostOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PinToHostOptimization);
      }
      if (ImplementationSelector != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ImplementationSelector);
      }
      if (AutoMixedPrecision != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) AutoMixedPrecision);
      }
      if (AutoMixedPrecisionMkl != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) AutoMixedPrecisionMkl);
      }
      if (AutoMixedPrecisionCpu != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) AutoMixedPrecisionCpu);
      }
      if (DisableMetaOptimizer != false) {
        size += 2 + 1;
      }
      if (UsePluginOptimizers != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) UsePluginOptimizers);
      }
      if (MetaOptimizerIterations != global::Tensorboard.RewriterConfig.Types.NumIterationsType.DefaultNumIters) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MetaOptimizerIterations);
      }
      if (MinGraphNodes != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MinGraphNodes);
      }
      if (ExperimentalDisableCompressedTensorOptimization != false) {
        size += 2 + 1;
      }
      if (ExperimentalDisableFoldingQuantizationEmulation != false) {
        size += 2 + 1;
      }
      if (MemoryOptimization != global::Tensorboard.RewriterConfig.Types.MemOptType.DefaultMemOpt) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MemoryOptimization);
      }
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MemoryOptimizerTargetNodeNameScope);
      }
      if (MetaOptimizerTimeoutMs != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(MetaOptimizerTimeoutMs);
      }
      if (autoParallel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoParallel);
      }
      if (FailOnOptimizerErrors != false) {
        size += 2 + 1;
      }
      if (scopedAllocatorOpts_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScopedAllocatorOpts);
      }
      size += optimizers_.CalculateSize(_repeated_optimizers_codec);
      size += customOptimizers_.CalculateSize(_repeated_customOptimizers_codec);
      if (interOptimizerVerifierConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InterOptimizerVerifierConfig);
      }
      if (postOptimizationVerifierConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PostOptimizationVerifierConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RewriterConfig other) {
      if (other == null) {
        return;
      }
      if (other.CpuLayoutConversion != global::Tensorboard.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) {
        CpuLayoutConversion = other.CpuLayoutConversion;
      }
      if (other.LayoutOptimizer != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        LayoutOptimizer = other.LayoutOptimizer;
      }
      if (other.ConstantFolding != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        ConstantFolding = other.ConstantFolding;
      }
      if (other.ShapeOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        ShapeOptimization = other.ShapeOptimization;
      }
      if (other.Remapping != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        Remapping = other.Remapping;
      }
      if (other.CommonSubgraphElimination != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        CommonSubgraphElimination = other.CommonSubgraphElimination;
      }
      if (other.ArithmeticOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        ArithmeticOptimization = other.ArithmeticOptimization;
      }
      if (other.DependencyOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        DependencyOptimization = other.DependencyOptimization;
      }
      if (other.LoopOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        LoopOptimization = other.LoopOptimization;
      }
      if (other.FunctionOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        FunctionOptimization = other.FunctionOptimization;
      }
      if (other.DebugStripper != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        DebugStripper = other.DebugStripper;
      }
      if (other.DisableModelPruning != false) {
        DisableModelPruning = other.DisableModelPruning;
      }
      if (other.ScopedAllocatorOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        ScopedAllocatorOptimization = other.ScopedAllocatorOptimization;
      }
      if (other.PinToHostOptimization != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        PinToHostOptimization = other.PinToHostOptimization;
      }
      if (other.ImplementationSelector != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        ImplementationSelector = other.ImplementationSelector;
      }
      if (other.AutoMixedPrecision != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        AutoMixedPrecision = other.AutoMixedPrecision;
      }
      if (other.AutoMixedPrecisionMkl != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        AutoMixedPrecisionMkl = other.AutoMixedPrecisionMkl;
      }
      if (other.AutoMixedPrecisionCpu != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        AutoMixedPrecisionCpu = other.AutoMixedPrecisionCpu;
      }
      if (other.DisableMetaOptimizer != false) {
        DisableMetaOptimizer = other.DisableMetaOptimizer;
      }
      if (other.UsePluginOptimizers != global::Tensorboard.RewriterConfig.Types.Toggle.Default) {
        UsePluginOptimizers = other.UsePluginOptimizers;
      }
      if (other.MetaOptimizerIterations != global::Tensorboard.RewriterConfig.Types.NumIterationsType.DefaultNumIters) {
        MetaOptimizerIterations = other.MetaOptimizerIterations;
      }
      if (other.MinGraphNodes != 0) {
        MinGraphNodes = other.MinGraphNodes;
      }
      if (other.ExperimentalDisableCompressedTensorOptimization != false) {
        ExperimentalDisableCompressedTensorOptimization = other.ExperimentalDisableCompressedTensorOptimization;
      }
      if (other.ExperimentalDisableFoldingQuantizationEmulation != false) {
        ExperimentalDisableFoldingQuantizationEmulation = other.ExperimentalDisableFoldingQuantizationEmulation;
      }
      if (other.MemoryOptimization != global::Tensorboard.RewriterConfig.Types.MemOptType.DefaultMemOpt) {
        MemoryOptimization = other.MemoryOptimization;
      }
      if (other.MemoryOptimizerTargetNodeNameScope.Length != 0) {
        MemoryOptimizerTargetNodeNameScope = other.MemoryOptimizerTargetNodeNameScope;
      }
      if (other.MetaOptimizerTimeoutMs != 0L) {
        MetaOptimizerTimeoutMs = other.MetaOptimizerTimeoutMs;
      }
      if (other.autoParallel_ != null) {
        if (autoParallel_ == null) {
          AutoParallel = new global::Tensorboard.AutoParallelOptions();
        }
        AutoParallel.MergeFrom(other.AutoParallel);
      }
      if (other.FailOnOptimizerErrors != false) {
        FailOnOptimizerErrors = other.FailOnOptimizerErrors;
      }
      if (other.scopedAllocatorOpts_ != null) {
        if (scopedAllocatorOpts_ == null) {
          ScopedAllocatorOpts = new global::Tensorboard.ScopedAllocatorOptions();
        }
        ScopedAllocatorOpts.MergeFrom(other.ScopedAllocatorOpts);
      }
      optimizers_.Add(other.optimizers_);
      customOptimizers_.Add(other.customOptimizers_);
      if (other.interOptimizerVerifierConfig_ != null) {
        if (interOptimizerVerifierConfig_ == null) {
          InterOptimizerVerifierConfig = new global::Tensorboard.VerifierConfig();
        }
        InterOptimizerVerifierConfig.MergeFrom(other.InterOptimizerVerifierConfig);
      }
      if (other.postOptimizationVerifierConfig_ != null) {
        if (postOptimizationVerifierConfig_ == null) {
          PostOptimizationVerifierConfig = new global::Tensorboard.VerifierConfig();
        }
        PostOptimizationVerifierConfig.MergeFrom(other.PostOptimizationVerifierConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LayoutOptimizer = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 16: {
            DisableModelPruning = input.ReadBool();
            break;
          }
          case 24: {
            ConstantFolding = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 32: {
            MemoryOptimization = (global::Tensorboard.RewriterConfig.Types.MemOptType) input.ReadEnum();
            break;
          }
          case 42: {
            if (autoParallel_ == null) {
              AutoParallel = new global::Tensorboard.AutoParallelOptions();
            }
            input.ReadMessage(AutoParallel);
            break;
          }
          case 50: {
            MemoryOptimizerTargetNodeNameScope = input.ReadString();
            break;
          }
          case 56: {
            ArithmeticOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 64: {
            DependencyOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 72: {
            LoopOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 80: {
            FunctionOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 88: {
            DebugStripper = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 96: {
            MetaOptimizerIterations = (global::Tensorboard.RewriterConfig.Types.NumIterationsType) input.ReadEnum();
            break;
          }
          case 104: {
            ShapeOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 112: {
            Remapping = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 120: {
            ScopedAllocatorOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 130: {
            if (scopedAllocatorOpts_ == null) {
              ScopedAllocatorOpts = new global::Tensorboard.ScopedAllocatorOptions();
            }
            input.ReadMessage(ScopedAllocatorOpts);
            break;
          }
          case 136: {
            MinGraphNodes = input.ReadInt32();
            break;
          }
          case 144: {
            PinToHostOptimization = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 152: {
            DisableMetaOptimizer = input.ReadBool();
            break;
          }
          case 160: {
            MetaOptimizerTimeoutMs = input.ReadInt64();
            break;
          }
          case 168: {
            FailOnOptimizerErrors = input.ReadBool();
            break;
          }
          case 176: {
            ImplementationSelector = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 184: {
            AutoMixedPrecision = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 192: {
            CommonSubgraphElimination = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 200: {
            AutoMixedPrecisionMkl = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 208: {
            ExperimentalDisableCompressedTensorOptimization = input.ReadBool();
            break;
          }
          case 216: {
            ExperimentalDisableFoldingQuantizationEmulation = input.ReadBool();
            break;
          }
          case 224: {
            UsePluginOptimizers = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 232: {
            AutoMixedPrecisionCpu = (global::Tensorboard.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 400: {
            CpuLayoutConversion = (global::Tensorboard.RewriterConfig.Types.CpuLayout) input.ReadEnum();
            break;
          }
          case 802: {
            optimizers_.AddEntriesFrom(input, _repeated_optimizers_codec);
            break;
          }
          case 1602: {
            customOptimizers_.AddEntriesFrom(input, _repeated_customOptimizers_codec);
            break;
          }
          case 2402: {
            if (interOptimizerVerifierConfig_ == null) {
              InterOptimizerVerifierConfig = new global::Tensorboard.VerifierConfig();
            }
            input.ReadMessage(InterOptimizerVerifierConfig);
            break;
          }
          case 2410: {
            if (postOptimizationVerifierConfig_ == null) {
              PostOptimizationVerifierConfig = new global::Tensorboard.VerifierConfig();
            }
            input.ReadMessage(PostOptimizationVerifierConfig);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RewriterConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Toggle {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("ON")] On = 1,
        [pbr::OriginalName("OFF")] Off = 2,
        /// <summary>
        /// Enable some aggressive optimizations that use assumptions that TF graphs
        /// may break. For example, assume the shape of a placeholder matches its
        /// actual feed.
        /// </summary>
        [pbr::OriginalName("AGGRESSIVE")] Aggressive = 3,
        /// <summary>
        /// Run MLIR pass if there's one implemented in TFG, do nothing otherwise.
        /// I.e., if there's no corresponding TFG pass, it's an OFF. This is supposed
        /// to be mapped with `ON` and there's no `AGGRESSIVE` in MLIR pass now.
        /// </summary>
        [pbr::OriginalName("EXPERIMENTAL_MLIR")] ExperimentalMlir = 4,
        /// <summary>
        /// Run both MLIR and Grappler passes consecutively and MLIR pass will come
        /// first.
        /// </summary>
        [pbr::OriginalName("EXPERIMENTAL_BOTH")] ExperimentalBoth = 5,
      }

      /// <summary>
      /// Enum for layout conversion between NCHW and NHWC on CPU. Default is OFF.
      /// </summary>
      public enum CpuLayout {
        [pbr::OriginalName("NO_CONVERSION_ON_CPU")] NoConversionOnCpu = 0,
        [pbr::OriginalName("NCHW_TO_NHWC")] NchwToNhwc = 1,
        [pbr::OriginalName("NHWC_TO_NCHW")] NhwcToNchw = 2,
      }

      /// <summary>
      /// Enum controlling the number of times to run optimizers. The default is to
      /// run them twice.
      /// </summary>
      public enum NumIterationsType {
        [pbr::OriginalName("DEFAULT_NUM_ITERS")] DefaultNumIters = 0,
        [pbr::OriginalName("ONE")] One = 1,
        [pbr::OriginalName("TWO")] Two = 2,
      }

      public enum MemOptType {
        /// <summary>
        /// The default setting (SCHEDULING and SWAPPING HEURISTICS only)
        /// </summary>
        [pbr::OriginalName("DEFAULT_MEM_OPT")] DefaultMemOpt = 0,
        /// <summary>
        /// Disabled in the meta-optimizer.
        /// </summary>
        [pbr::OriginalName("NO_MEM_OPT")] NoMemOpt = 1,
        /// <summary>
        /// Driven by manual op-level annotations.
        /// </summary>
        [pbr::OriginalName("MANUAL")] Manual = 2,
        /// <summary>
        /// Swapping heuristic will move a tensor from the GPU to the CPU and move
        /// it back when needed to reduce peak memory usage.
        /// </summary>
        [pbr::OriginalName("SWAPPING_HEURISTICS")] SwappingHeuristics = 4,
        /// <summary>
        /// Recomputation heuristics will recompute ops (such as Relu activation)
        /// during backprop instead of storing them, reducing peak memory usage.
        /// </summary>
        [pbr::OriginalName("RECOMPUTATION_HEURISTICS")] RecomputationHeuristics = 5,
        /// <summary>
        /// Scheduling will split big ops such as AddN and try to enforce a schedule
        /// of the new computations that decreases peak memory usage.
        /// </summary>
        [pbr::OriginalName("SCHEDULING_HEURISTICS")] SchedulingHeuristics = 6,
        /// <summary>
        /// Use any combination of swapping and recomputation heuristics.
        /// </summary>
        [pbr::OriginalName("HEURISTICS")] Heuristics = 3,
      }

      /// <summary>
      /// Message to describe custom graph optimizer and its parameters
      /// </summary>
      public sealed partial class CustomGraphOptimizer : pb::IMessage<CustomGraphOptimizer> {
        private static readonly pb::MessageParser<CustomGraphOptimizer> _parser = new pb::MessageParser<CustomGraphOptimizer>(() => new CustomGraphOptimizer());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CustomGraphOptimizer> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorboard.RewriterConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer(CustomGraphOptimizer other) : this() {
          name_ = other.name_;
          parameterMap_ = other.parameterMap_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer Clone() {
          return new CustomGraphOptimizer(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "parameter_map" field.</summary>
        public const int ParameterMapFieldNumber = 2;
        private static readonly pbc::MapField<string, global::Tensorboard.AttrValue>.Codec _map_parameterMap_codec
            = new pbc::MapField<string, global::Tensorboard.AttrValue>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Tensorboard.AttrValue.Parser), 18);
        private readonly pbc::MapField<string, global::Tensorboard.AttrValue> parameterMap_ = new pbc::MapField<string, global::Tensorboard.AttrValue>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, global::Tensorboard.AttrValue> ParameterMap {
          get { return parameterMap_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CustomGraphOptimizer);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CustomGraphOptimizer other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!ParameterMap.Equals(other.ParameterMap)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= ParameterMap.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          parameterMap_.WriteTo(output, _map_parameterMap_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += parameterMap_.CalculateSize(_map_parameterMap_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CustomGraphOptimizer other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          parameterMap_.Add(other.parameterMap_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                parameterMap_.AddEntriesFrom(input, _map_parameterMap_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
